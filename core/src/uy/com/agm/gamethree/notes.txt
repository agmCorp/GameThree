PROXIMAS VERSIONES
------------------
- buscar algun popup automatico para pedir ranking y opinion.
- ver algún robot para aumentar bajadas.
- Creo que showRedFlash debería estar en dimScreen. Hay que ver si su help también.
El problema es que si hay un help no modal en pantalla y se me escapa un enemigo, la redscreen cierra ese help para mostrarse.
Capaz que se arregla poniendo en el stack ademas de image una nueva capa llamada redscreen.
Otra que puedo hacer, es que la aparecion de la red screen sea siempre que no haya alguna imagen en pantalla, o sea
  public void showRedFlash() {
  if (!isImageVisible()) {
        showImage(redFlash, RED_FLASH_TIME);
        }
    }
- Agregar credits con cuenta bancaria para donación, algo asi:
support this game:
(icono corazón) Support the developer by paying above the minimum price
+$1.00 +$2.00 +$5.00 +$10.00
Pay with paypal, pay with card bitcoin
Agregar dir de mail de contacto.
- hacer videos cuando termine los corazones, cambiar las imagenes de la playStore y github porque cambio el hud.
- Poner un banner en la interfase scene2d? En algunas pantallas se puede, no en todas.
Poner un adv al volver en el boton de la pantalla game over. Es importante, da plata.
- En la pantalla de creditos poner donación y rank, capaz en una segunda pantalla.
- Integrar OpenFeint (google play services) a mi juego. Necesito al menos 5 logros. Tengo buenos tutoriales en bookmarks
libgdx/googlePlayServicesOpenFeint. No se si vale la pena el esfuerzo.
- Con los puntos que voy generando (monedas recogidas), se pueden comprar nuevos poderes o mas vidas o lo que se me ocurra.
puedo poner un boton para dar puntos si ves un anuncio.

PRIORIDAD 1
-----------
- Hacer una skin con el skin composer para aprender. También se puede crear programando.
utilice orange: https://github.com/czyzby/gdx-skins/tree/master/orange
- Que la help screen red aparezca la primera vez que se va un bicho independiente del nivel (no puedo, necesitaria
un singleton de aplicacion). En ese singleton ademas puede estar el gamecontrollerhelp.
- Poder aabb que los deja quietos:
IMPLEMENTACION:
Cada enemigo deberia tener un metodo freeze() y asegurarme que no disparen y ta.
Capaz que hasta queda lindo que mueran con 1 disparo, pero sino no.
Si esta "freeze" llamo al onDestroy().
Capaz lo que puedo hacer ademas, es usar internamente este metodo para evitar que los bichos sigan
moviendose cuando estoy dyingup/down...que retomen el movimiento cuando volvi a jugar.

PRIORIDAD 2
-----------
- una cosa que se podria hacer es ponerle una pequeña barrita de energia a los enemigos que mueren
por varios disparos.

PRIORIDAD 3
-----------
- Hacer un mapa de los niveles (opcional)
- Habria que optimizar evitando llamar mil veces a los gets Assets.getInstance().getBossOne(), etc.
- Deberia hacer una clase KinematicBackgroundObject analoga a StaticBackgroundObject y heredar de ella en Edge y en Bridge. Intenté una
vez y me resultó complicado. Tambien deberia hacer una interfaz llamada GameObject que tenga metodos generales a TODOS mis objetos del juego.
Candidatos whoami, getcurrentstate, getboundingmeters...pero hay que estudiarlo.
Esa interfaz la puedo usar ademas dentro de ActorDef.
- Poner particulas parece facil, capaz lluvia.
- Poner alguna animacion linda de hero cuando mata al boss y gana el nivel.
Si hero le gana al boss, puedo poner al final del hero.update(): if boss is dead, then currentstate = dancing.
Y en el update si el estado es dancing, hacer una animacion graciosa.
Si pongo pausa en el juego podría poder alguna animación graciosa de Hero...creo que basta con hacerle a hero un método drawEspecial() que haga
la animacion y llamarlo desde el método renderGame() si estoy en pausa..pero no se
- Ver si puedo reducir el tamano de la musica (sonido no ocupa nada).
- Ver si en los metodos criticos de update y draw (render) no estoy haciendo muchos new.
- Los tiempos y cantidad de imagenes en las clases Assetxx no estan en constantes, creo no interesa.
- Poder de disparo con tipo de movimiento (boomerang):
        Se me ocurre modelarlo solo con un enumerado recibido en el constructor de heroBullet o EnemyBullet
        y luego en el stateShoot de HeroBullet o EnemyBullet. Aunque lo más prolijo que se me ocurre sería
        definir una clase nueva FancyBullet (o BoomerangBullet) que herede de Weapon y tenga toda su lógica loca adentro (como la tiene HeroBullet o EnemyBullet).
        Luego una strategy nueva que cree el objeto pasando FancyBullet para que el b2worldcreator lo cree.

SOLO IDEAS
----------
- hacer una bala grandota y ruidosa con shake capaz
- Para nivel 4 hacer un puente que rote con las junturas esas de motor
- enemigos:
    - hay que dispararle mucho para matarlo.
    - el boss puede estar acompanado de otros simples, ojo con el metodo Enemy.onDestroy().
    - se mueva en 8 horizontal y dispare abanico de balas como mi poder fire.
    - boss que me sigue
    - boss con varios ojos (circulos box2d) que cambian de color y en un estado disparan. Se mueven juntos y están
      rodeados por una gran textura que es el enemigo!
    - luego de un rato hace blink y desaparece y vuelve a aparecer. Disparando siempre.
    - enemigo que al recibir disparo se parte en 2 y luego de un rato se vuelve a juntar (como el enemyfour pero
    se parte y hay que no tocar esas partes).
    - enemigo que viene vertical hacia abajo y cuando llega a la linea media de la pantalla, determina (en ese
    instante) en donde esta el hero y va hacia ahi.
    - enemigo que es como una estella (cometa). Para ese efecto agregar varias veces el sprite con distinto alpha.
    Se mueve rapido derecho en diagonal.
- minuto 33.43 puentes dinámicos https://www.youtube.com/watch?v=SJM6mxXgW50&t=1843s
- para la version escritorio creo me conviene usar heroLeft y heroRight porque tengo las animaciones y es facil incluirlas.
Con el boss 2 no se...no logro visualizar esos cambios en perspectiva.
- Frases:
    - Humans are the real monsters
    - La que anoté por ahí en el papel: You were the monster all along

DUDAS Y BUGS
------------
- Cuando todo esto termine contactar a cooper de linkedin y preguntarle las dudas tecnicas y
ademas consultar si es mejor usar box2d o arreglos para detectar colisiones. Si conoce algun
detector de colisiones (solo que detecte, sin resolver el choque).
Quisiera la opinion de alguien que sepa sobre si es mejor usar box2d para detectar colisiones (y luchar con los
movimientos no pudiendo cambiar la posición) o es mejor usar overlaps (donde capaz tengo que hacer miles de combinaciones
de cruzamientos). Hay algún otro enfoque?.
- No se donde tengo que hacer Assets.dispose(), lo puse en gamethree
- Manejo de memoria y uso de Vector2 y uso de Labels en las pantallas.
El vector2 no tiene dispose, las labels tampoco...
- Queda el bug de que si reproducis un sonido y luego cambias de aplicacion, al volver (el juego esta en pausa) reproduce
el resto del sonido. No lo supe arreglar...
- A veces los sonidos no se reproducen
*- Un enemyFour en el nivel 2 me quedo eternamente yendo a la derecha trabado contra el borde. Programe que el targetX este siempre
antes de un limitederecho o limiteizquierdo. Deberia haber quedado solucionado.
*- Cuando disparo con fire balls a los bichos verdes (enemyEight), algunos suben pegados al borde en el nivel 2.
No se arreglo seteando velocity threshold de world. El error se debe a que el movimiento de enemyEight se ve un poquito afectado
ya sea por el disparo o porque yo lo empujo y se cumple la condición de salida de path2:
b2body.getPosition().y > screen.getGameCam().position.y - screen.getGameViewPort().getWorldHeight() / 4
Luego de eso, viene path3 que es ir a la esquina (justamente la esquina que está exactamente arriba, subiendo por el borde).
Solucione eso cambiando la condicion de salida de path1, path2 y path3. Ahora tabien considera la posicion x del bicho.
Deberia haber quedado solucionado.
- En el nivel 3, quedo un audio de enemigo 8 siempre escuchándose. Eso significa que el enemigo quedo trancado fuera de la visual.
Cuando agarré un colTwo recien ahi desaparecio.
- En el nivel1, una pantalla antes del segundo puente, sobre la derecha, para mi queda una bala oculta que te mata.
Me pasó algo parecido en el nivel 3.
Confirmado que es un bug.
Se me ocurre que solo se dibujen los bordes de las balas del enemigo (para así poder debuguear y distinguirlas) porque es lo unico
que me puede matar.
*- En una version de la PlayStore (version 5 y posteriores) me pasaba que a veces no aparecia el trofeo en la pantalla levelComplete pero
si aprecian las etiquetas de highscore y demas. Tambien me pasaba que a veces la pantalla de highscores aparecia con espacios
chicos entre filas de la tabla. Lo peor es que a veces no cargaba los niveles en selectlevels y aprecia todo vacio.
Para reproducir esto ultimo: Mato todas las apps de android, entro al juego, voy a highscores rapido, vuelvo, voy a help rapido (o credits),
vuelvo, voy a select level y se ven todos vacios. Al parecer solo pasa en mi celular, supongo yo por tanta instalación de debug.
Deberia haber quedado solucionado.
- Las balas no deberian rebotar cambiando su velocidad a mano, sino box2d deberia calcular como rebotan naturalmente.
Si tengo una bala de enemigo que va de norte a sur y yo con mi escudo (powertwo) la choco viniendo desde el norte, la bala
cambia de direccion hacia mi y vuelve a rebotar y queda mal. Ojo que puede quedar la bala flotando quieta si programo un rebote
natural. Intente corregir esto, ver Weapon.onbounce(). Hice lo que pude, parece estar bien.
- Hay situaciones en donde me aparece redScreen (todo rojo) y encima alguna de las pantallas modales (solo se ve el pulgar). Creo que
es la pantalla que dice infoScreen.redFlashHelp=WATCH OUT!\nDon't let your enemies\nflee! That hurts you!. No se puede leer, solo
se ve el pulgar. No se si es un bug o es que aparece solo cuando seteo DISABLE_ENDURANCE_COUNT = true;

TENGO
-----
- borders, edges, paths, obstacles, powerboxes, enemies, bosses, items, weapons
- enemigos comunes 11 (uso 3 o 4 enemigos por nivel):
one - amarillo
two - murcielago
three - bola negra
four - congelados
five - dragon en circulos
six - rayo
seven - se multiplica
eight - bicho verde cometa
nine - fenix
ten - 2 circulos
eleven - hombres de piedra
twelve - vampirito violeta
- bosses: 4
- poderes 5 -3 de habilidad, 2 de fuego- (2 poderes por nivel)
- 1 moneda x 6
- 1 shuriken
- 1 item vidas
- 1 item endurance (resistencia)
- 1 your soul is mine

ESTIMACION
----------
https://www.youtube.com/watch?v=SJM6mxXgW50&t=1843s
En youtube el knight se desplaza 10 pixels por segundo aprox.
El primer nivel dura 5 minutos (300 segundos).
En youtube el knight tiene 260 pixels de alto.
Entonces el nivel total mide 260 (primer pantalla) + 10 pixels * 300s = 3260.

O sea, son en total: 3260 / 260 = 12.5 pantallas, redondeo a 13.

Velocidad:
Se mueve a un 3.8% de pantalla por segundo.
En mi juego seria 3.8 de 800 por segundo, o sea, 30.4 pixels por segundo.

RESUMEN
En mi juego seria 0.304 la velocidad.
En mi juego serian 13 pantallas

Yo igual hice 10 pantallas, 13 me parece mucho porque me cuesta llenarlas de enemigos.

TILESET
-------
map 32x32 sin margin ni spacing
15 tiles de ancho (480/32 = 15)
250 de alto (10 pantallas, cada una de 25 tiles, 25 x 32 = 800 = viewportheight)
Mi mundo ancho 480, alto 800
mis texturas miden 1024 x 1024

CUSTOM PROPERTIES
-----------------
powerOne (int): ghost mode, indica el tiempo de uso
powerTwo (int): escudo, indica el tiempo de uso
powerThree (int): cambia el poder de disparo, indica el tiempo de uso
powerFour (int): thogh mode, indica el tiempo de uso
powerFive (int): espadas, indica el tiempo de uso
colOne (string): moneda
colTwo (string): mata a todos
colThree (string): vida extra / energy extra
colSilverBullet (string): shuriken

strength (int): dureza de la powerbox
timesItFreeze (int): indica cuantas veces se puede congelar el enemyFour
enemyBullet (string): indica si el enemigo dispara
shootWhenVisible (string): dispara al aparecer en camara
fireDelay (int): demora entre disparos
bridgeType (int): imagen para el bridge 1 bridgeA, 2 bridgeB, 3 bridgeC

HERRAMIENTAS
------------
- TiledEditor: para crear el nivel
- TexturePacker: para crear los assets de personajes y empacar las animaciones
- ShoeBox: para agarrar una imagen grande con muchos sprites y separar cada sprite en un archivo distinto numerado.
- https://ezgif.com/split: me permite separar un gif animado en frames (también permite convertir video en gif)
- http://www.online-image-editor.com/: editor en linea
- sourceTree para administrar git
- https://audio.online-convert.com/es/convertir-a-ogg: conversor de mp3 a ogg
- https://github.com/BrentAureli/SuperMario / https://www.patreon.com/BrentAureli
- https://freesound.org, user aclaveri/2es...etc. Para sonido.
- https://www.youtube.com/watch?v=dxPf1M7YORU&feature=youtu.be para crear fonts ver ese video
- https://www.imgonline.com.ua/eng/cut-photo-into-pieces.php para cortar una imagen en pedazos iguales
- pngcrush para reducir el tamano de los .png (https://pmt.sourceforge.io/pngcrush/)
https://developer.android.com/topic/performance/reduce-apk-size.html
- https://cloudconvert.com/svg-to-png: svg to png converter
- https://bulkresizephotos.com: para redimensionar imagenes batch
- Tiny png api key 7yaS9nq0e-PmOCid1k6me6gk_bjTamPq (para usar en Texture Packer)
También lo puedo usar directo en https://tinypng.com/ para imágenes menores a 5 megas.
Para imágenes más pesadas usar curl. Ver "lecciones aprendidas 24".
- http://flamingtext.com/logo/Design-Cartoon Para crear fonts bonitas
- Bulk Rename Utility (Windows) para renombrar archivos.

LECCIONES APRENDIDAS
--------------------
1)
    Posicon + velocidad da posicion
    Para ir de A a B, debo restar los vectores B - A.
    La diferencia entre la posicion actual y la posicion futura es la VELOCIDAD (VECTOR VELOCIDAD).

    Vector2 position = new Vector2();
    Vector2 velocity = new Vector2();
    Vector2 acceleration = new Vector2(0, -10);
    while(simulationRuns) {
        float deltaTime = getDeltaTime();
        velocity.add(acceleration.x * deltaTime, acceleration.y * deltaTime);
        position.add(velocity.x * deltaTime, velocity.y * deltaTime);
    }
    This is called numerical Euler integration, and it is the most intuitive of the integration methods
    used in games. We start off with a position at (0,0), a velocity given as (0,0), and an acceleration
    of (0,–10), which means that the velocity will increase by 1 m/s on the y axis. There will be no
    movement on the x axis. Before we enter the integration loop, our object is standing still. Within the
    loop, we first update the velocity, based on the acceleration multiplied by the delta time, and
    then update the position, based on the velocity multiplied by the delta time. That's all there is to
    the big, scary word integration.

2)
    Personaje a partir de gif animado:
    - Agarrar un gif animado y separarlo en frames con https://ezgif.com/split.
    - Abrir cada imagen con Paint.net y ponerle fondo transparente.
    - Abrir cada imagen con ShoeBox, y con la funcionalidad "Extract Sprites" extraer el dibujo quitando asi fondo innecesario.
    - Usar Paint.net, canvas size para darle a todas el mismo tamaño.
    - Renombrar cada imagen como una secuencia: img_01.png, img_02.png, etc. Usar C:\Alvaro\Develop\Android\20171202\RenameFiles
    - Usar el TexturePacker para agregarlas al atlas.

    Personaje a partir de un gran archivo en donde estan las imagenes todas juntas:
    - Abrir la imagen con ShoeBox y usar la funcionalidad "Extract Sprites".
    - Usar Paint.net, canvas size para darle a todas el mismo tamaño.
    - Renombrar cada imagen como una secuencia: img_01.png, img_02.png, etc. Usar C:\Alvaro\Develop\Android\20171202\RenameFiles
    - Usar el TexturePacker para agregarlas al atlas.

3)
    Manejo de memoria: https://github.com/libgdx/libgdx/wiki/Memory-management

4)
    En las layers (tiled) pongo un rectangulo de cualquier tamano.
    Eso me da las coordenadas x, y en donde va a estar el enemigo, que son las del vertice inferior izquierdo.
    Luego cuando se crea el enemigo, el setbounds usa el tamano de la textura / PPM para definir el tamano.
    Ese tamanio son pixels / (pixels / metro) o sea, metros.
    Entonces no importaria el tamano del rectangulo en las layers.

6)
    SISTEMA DE COORDENADAS
    ----------------------
    SPRITE:
    setPosition(x,y) indica el vertice inferior izquierdo de un rectangulo definido con setBounds.
    setBounds(x, y, width, hegiht) indica un rectangulo cuyo vertice inferior izquierdo esta en x, y.
    Siempre debo trabajar con coordenadas del mundo, es decir, metros (no pixels).
    En otras palabras, el origen de coordenadas esta en su vertice inferior izquierdo.

    CAMARA:
    (cam.x, cam.y) es el punto central de la "pantalla".
    El origen (0, 0) está en el vértice inferior izquierdo.

    BOX2D
    Los objetos de box2d (b2body) tienen como origen de coordenadas en su centro.
    Es decir su centro es (b2body.getPosition().x, b2body.getPosition().y).
    Aca también se trabaja con metros.

    MUNDO
    Su origen de coordenadas esta en su esquina inferior izquierda.
    Identico a SPRITE.

    TOUCH EVENTOS
    Su origen está en la esquina superior izquierda (lpmqtp)
    Es decir, el (0, 0) esta arriba a la izquierda.

    TEXTURAS
    Tienen un u y v. No recuerdo exactamente. Es otro caso distinto.

    En resumen, siempre trabajar con metros en todo EL JUEGO.
    Para la GUI usar una cámara en pixels.

    Acá explica muy bien the Separation of concerns entre logica y render. Así como la necesidad de usar metros para el modelo,
    pixels para el render y PPM para relacionarlos:
    http://www.aurelienribon.com/post/2011-04-logic-vs-render-separation-of-concerns

7)
    Para levantar proyecto github:
    - instalar java 8 y definir JAVA_HOME
    - instalar android sdk y definir ANDROID_HOME (pues la usa git)
    - instalar git y agregarlo al PATH. Definir su proxy:
    git config --global http.proxy http://amorales:tqspy.7719@proxy.bse.com.uy:8080
    - instalar maven y agregarlo al PATH
    - instalar android studio y en settings apuntar a la instalación de git. Definir su proxy, puse el del bse.
    - abrir android studio, open new project y seleccionar la carpeta androidStudioProjects.
    - luego checkout (vcs/checkout from version control) desde github: https://github.com/agmCorp/GameThree (https://github.com/BrentAureli/SuperMario)
    - cerrar andoid studio
    /* esto podría no ser necesario
    - ir a dos, dentro de gamethree:
    gradlew -Dhttp.proxyHost=proxy.bse.com.uy -Dhttp.proxyPort=8080 -Dhttps.proxyHost=proxy.bse.com.uy -Dhttps.proxyPort=8080 build
    Si es para supermario, puede ser que me falte alguna cosa de android, ahí tengo que abrir el sdk manager y bajarla.
    */
    - abrir andoid studio, darle luego open y seleccionar el archivo build.gradle, ahí pide proxy meter el del bse.
    - en settings deshabilitar configuration on demand
    - luego view/windows tools/gradle
    - luego dalre sincronizar, esperar que finalice  la indexacion
    Si le falta alguna librería de andoid, en el error da un link en donde pinchás y te la instala en shootStrategy\users\amorales\appdata\local\android\sdk.
    Sino el sdk Manager está en el menú tools/Android y ahí las cargo yo a mano hasta resolver todos los problemas.
    Tuve que editar el build.gradle de super mario y poner com.android.tools.build:gradle:2.3.0 en lugar de com.android.tools.build:gradle:2.3.0-beta1
    - cerrar el android studio, abrir el proyecto, crear el run deskotp, luego darle run y pide module, ponerle desktop.
    - la pc de mi trabajo no soporta opengl2.0 así que solo puedo ejecutar en android.

8)
   git fetch origin
   git reset --hard origin/master

   Puedo hacer un git pull, pero capaz lo mejor es hacer:
   git fetch // trae cambios pero no los aplica
   git diff // me muestra los cambios
   git merge // ejecuta cambios

   usar Sourcetree: Reset current branch to this commit
   Con eso hago un update forzado sobreescribiendo el local con el remoto.

9)
    Para generar el jar y correrlo en pc, dentro del proyecto ejecutar:
    gradlew desktop:dist

    El jar queda en GameThree\desktop\build\libs

    Aca explican como generar cada cosa:
    https://github.com/libgdx/libgdx/wiki/Gradle-on-the-Commandline

10)
    Para generar un BitmapFont usar SoeBox.
    Abrirlo y apretar "Bitmap Font". Eso copia al portapapeles un conjunto de letras.
    Abrir un editor grafico, seleccionar la herramienta para insertar texto y darle pegar.
    Eso pega todos los caracteres en pantalla, luego los edito como quiera cambiando colores, etc.
    Finalmente al png resultante, lo tiro nuevamente en la herramienta sobre "Bitmap Font", eso detecta
    los caracteres.
    Luego, para evitar tener que editar las settings a mano, debo apretar el boton "Auto fit Settings". Eso setea
    las propiedades de alto y ancho de cada letra para que se vea bien.
    Al salvar genera 2 archivos los cuales uso. Capaz que tengo que editarlos para cambiar una ruta absoluta que
    aparece alli (como en TiledEditor).

11)
    Para definir el tamaño (ancho y altura) de un sprite, debo usar setBoundaries.
    Luego puedo definir su posición con setPosition.
    Puedo hacer todo en un paso y definir tamaño y posición con setBoundaries.
    Si durante el ciclo de vida del personaje (Sprite) quiero cambiar su tramaño, puedo setear nuevamente setBoundaries y lo cambio.
    Esto lo hice por ejemplo en BossOne, BossTwo, PowerBox, etc. cuando cambio su animación para que exploten.
    Lo anterior funciona bien si el sprite no fue rotado, sino es muy complejo setear bien el tamaño nuevamente ya que si está rotado
    el ancho a veces se convierte en altura y viceversa. De igual manera rota el vértice inferior izquierdo y la verdad resulta muy muy complejo
    determinar el nuevo sistema de coordenadas.
    Lo que hice en esos casos fue definir un nuevo sprite (en una variable), seteando su setBoundaries, que la dibujo finalmente sobre el sprite
    del personaje en el método draw (ver por ejemplo BossOne, los sprites powerFXSprite y explosionFXSprite) aplicando
    la rotación y flip del sprite del personaje. Esto lo hice así porque es imposible deducir el ancho y altura del sprite
    BossOne ya que este se pasa rotando por la pantalla.

12)
   There are also the following methods that alter the bounding rectangle of a sprite (modifies the sprite's vertices):
   getBoundingRectangle(): recalculate vertices (see source code)
   setX(x)
   setY(y)
   setBounds(x,y,width,height)
   setSize(width,height)
   translate(diffX,diffY)
   translateX(diffX)
   translateY(diffY)

13)
   Para crear un proyecto con libgdx desde cero, seguir este link:
   http://libgdx.badlogicgames.com/documentation/gettingstarted/Importing%20into%20IDE.html

14)
    On Android, a Sound instance can not be over 1mb in size. If you have a bigger file, use Music

15)
    Cuando estoy invulnerable durante unos segundos por haber perdido una vida, no programar el
    poder agarrar items, porque eso cambia los filtros y me dejan vulnerable dependiendo del poder.

16)
    Debo hacer dispose de las cosas a las que les hice new. Si yo no les hice new (por ejemplo las texturas), no
    es mi responsabilidad (es la responsabilidad del assetManager).

17)
    IDEA GENERAL PARA EL METODO RENDER DE UN JUEGO CUALQUIERA:
    Within my game's render(), I first call my entityUpdate(delta), which updates and moves all of the objects in my game scaled
    by the distance
    traveled in time "delta" (it doesn't render them, just moves their position variables).
    Then I call entityManageCollisions(delta), which resolves all of the collisions caused by the update, then I finally call entityDraw(batch, delta),
    which uses delta to get the right frames for sprite animations, and actually draws everything on the screen.

18)
    No estoy seguro, pero para generar un apk release no firmado (o firmado con un keystore por defecto de android studio):
    Abrir el archivo android/build.gradle y clickear adentro.
    Se me habilita en el menu build la opcion Select Build Variant...
    Alli elijo Release, luego en el menu Build selecciono Build APK.

    Si hago cambios en los archivos .gradle, debo luego hacer un Rebuild project para que sean tomados en cuenta.
    Esto es para usar el ide, sino seria ejecutar las tareas gradle:
    Information:Gradle tasks [:android:assembleRelease, :core:assemble, :desktop:assemble]

    Para quitar el folder raw de los apk (tanto en debug como release), agregue en android/build.gradle:
    android {
        aaptOptions {
            ignoreAssetsPattern '!raw'
        }
    Para quitar el folder raw del jar (desktop) agregue en desktop/build.gradle:
    task dist(type: Jar) {
        ...
        exclude '**/raw/**'

    También seguí la información de esta guia (sección Tweaking) para generar jars (desktop) renombrados con fecha y hora:
    https://github.com/libgdx/libgdx/wiki/Gradle-on-the-Commandline
    salida ejemplo: gameThree-1.0-build-20180220_223045.jar

    Para generar los apks renombrados con informacion de version agregue en android/build.gradle:
    android {
    ...
        // Rename all output artifacts to include version information
        applicationVariants.all { variant ->
            variant.outputs.each { output ->
                def apkName = "gameThree_" + android.defaultConfig.versionName;
                if (variant.buildType.name.equals("release")) {
                    apkName += "_" + variant.buildType.name;
                }
                apkName += ".apk";
                output.outputFile = file("$project.buildDir/apk/" + apkName)
            }
        }
    }

    salida ejemplo: gameThree_1.0-build-20180220_221710.apk

    Finalmente, para optimizar el tamaño del apk leí la info de esta guía:
    https://developer.android.com/topic/performance/reduce-apk-size.html

    Agregué en android/build.gradle:
        buildTypes {
            debug {
                minifyEnabled true
                shrinkResources true
                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            }
            release {
                minifyEnabled true
                shrinkResources true
                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            }
        }

    Lo interesante además es el uso de la herramienta pngcrush.exe, que reduce el tamaño de los pngs.
    Si reduzco los dynamicObjects.png, gano algo así como medio mega en total.
    Pero la reducción más drástica se da con background.png (de cada nivel) en donde gano más de 2 megas.
    Para usar esa herramienta hice:
    >pngcrush.exe background.png salidaBackground.png

    De todos modos, lo mejor que encontre para reducir el tamano de las imagenes es usar TinyPng. Lo tiene
    integrado el TexturePacker, basta con hacerse una cuenta en TinyPng y obtener una clave para usar sus
    servicios. Eligiendo TinyPng en el combo del TexturePacker, reduzco todos los dynamicObjects. Para backgroud.png
    debo usar el curl (para invocar al servicio) porque la imagen es mayor a 5 megas (sino podria usar directo el
    sitio web). Para ello mando la imagen con C:\Alvaro\Develop\Android\20171202\Texturepacker\curl-7.59.0\I386\enviarImagen.bat.
    Luego de un rato reviso la respuesta en DOS y alli aparece una url la cual pego en cualquier browser y bajo mi imagen liviana.
    Ver lecciones aprendidas 24.

19)
    A dynamic body is a body which is affected by world forces and react to collisions. And you already met a million of them.
    A static body is a body which isn’t affected by world forces it does not react to collisions. It can’t be moved. Fullstop.
    A kinematic body is an hybrid body which is not affected by forces and collisions like a static body but can moved
    with a linear velocity like a dynamic body.

20)
   Mi criterio es el siguiente: En los eventos invocados por WorldContactListener.beginContact solo seteo estados.
   No toco velocidades ni nada, ni mucho menos toco el box2d. Todos arrancan con el prefio "on" (ej: onUse(), onHit(), onDead()).
   "No b2body can be changed when the simulation is occurring, we must wait for the next update cycle."
   En los update, según el estado es que cambio velocidades, posiciones, box2d, etc. Ese es mi criterio.
   Por eso por ejemplo en EnemyOne aparecen cosas como b2body.setLinearVelocity(velocity) dentro de stateAlive(float dt).
   Toco velocidades directamente dentro de WorldContactListener en endContact, porque al parecer allí es seguro (solo lo hago al invocar Hero.stop()).

21)
   Con setBound defino su tamaño y luego, si quiero, son setPosition su posición. Esta ultima tiene sentido llamarla si deseo cambiar la posición del sprite, por ejemplo,
   para alinearla con su box2d después de la simulación física.

22) setRotation, angle() y lpmqtrmpc:
    Si tengo un vector y hago vector.angle() eso me devuelve el ángulo que forma el vector puesto en el punto (0, 0) con respecto al eje x,
    medido en sentido antihorario. Punto, se acabó.
    Este es el sistema de coordenadas:
                    90
                    |
                    |
     cuadrante II   |  cuadrante I
                    |
      180 ----------|---------- 0/360
                    |
                    |
     cuadrante III  |  cuadrante IV            |
                    |
                   270

    Cuando dibujo una textura con el método draw(Batch batch) de la clase Sprite, se dibuja paradita tal cual la veo en mis archivos de imágenes.
    Si utilizo el método draw de la clase Batch, ahí la dibuja acostada sobre el eje x y mirando hacia la derecha.
    Se puede decir entonces que Sprite.draw() es equivalente a Batch.draw() + setRotation(90).
    En lo posible debo usar siempre Sprite.draw() que como comenté antes, dibuja la textura tal cual la veo en mis archivos (paradita).
    Si hago Sprite.setRotation(), eso la rota en sentido antihorario, si hago Sprite.rotation() la rota también en sentido antihorario pero permite acumular rotaciones.
    Entonces Sprite.rotation(20) + Sprite.rotation(30) = Sprite.setRotation(50).

    Lo divertido de esto, es que si tengo un vector velocidad vel que está en el cuadrante I apuntando hacia afuera, y quiero hacer que mi textura (supongamos un hombrecito)
    mire hacia ese lugar, como los angulos se rotan antihorario y se miden antihorario y la textura de Sprite.draw() está "rotada 90 con respecto a la matemática" debo hacer:
    anguloAGirarTextura = 90 (cuadrante II) + 90 (cuadrante III) + 90 (cuadrante IV) + vel.angle();
    sprite.setRotation(anguloAGirarTextura)

    Si el vector velocidad está en los cuadrantes II, III y IV:
    anguloAGirarTextura = vel.angle() - 90 (cuadrante I);
    sprite.setRotation(anguloAGirarTextura)

    Libgdx no trabaja con ángulos negativos aunque al parecer es robusto y los giros de ángulos negativos lo hace en sentido horario.
    No usar ángulos negativos porque es impredecible para mi.
    No se si alguna vez vector.angle() retorna exactamente cero o exactamente 360. Creo que puede llegar a retornar cero pero no 360.
    Es decir, no conozco ese valor borde.

23)
    Given a range between Max and Min, the following is the general formula for generating random numbers between a given minimum and maximum number:

    (Max - Min) * random(0 to 1) + Min = random(Min to Max)

24)
    El tamaño grande del apk se debe principalmente a las imágenes y al audio.
    Para comprimir las imágenes usar Texture Packer seleccionando "Compression TinyPNG".
    Para usarlo debo tener una key de developer (7yaS9nq0e-PmOCid1k6me6gk_bjTamPq). La conseguí yendo
    al sitio https://tinypng.com/developers y registrando mi direccion de correo alvaro.gabriel.morales@gmail.com. Te envian un mail
    en donde podes ver cuantas imágenes llevas comprimidas (maximo 500 por mes): https://tinypng.com/dashboard/developers
    Para reducir background.png no lo puedo hacer por la web de tinypng.com porque es muy pesada.
    Utilizo curl para poder usar la api como servicio:
    C:\Alvaro\Develop\Android\20171202\Texturepacker\curl-7.59.0\I386>enviarImagen.bat background.png
    Eso después de un rato genera esta salida:

    C:\Alvaro\Develop\Android\20171202\Texturepacker\curl-7.59.0\I386>curl --user api:7yaS9nq0e-PmOCid1k6me6gk_bjTamPq --data-binary @background.png -i https://api.tinify.com/shrink
    HTTP/1.1 100 Continue

    HTTP/1.1 201 Created
    Date: Tue, 27 Mar 2018 00:38:42 GMT
    Content-Type: application/json
    Content-Length: 203
    Connection: keep-alive
    Compression-Count: 7
    Cache-Control: no-cache
    Location: https://api.tinify.com/output/htkrx9ru6pjp1heyz4q5grx6egk7bxmq

    {"input":{"size":7833078,"type":"image/png"},"output":{"size":1351755,"type":"image/png","width":2048,"height":2048,"ratio":0.1726,"url":"https://api.tinify.com/output/htkrx9ru6pjp1heyz4q5grx6egk7bxmq"}}

    Entonces si voy a la url que alli dice (https://api.tinify.com/output/htkrx9ru6pjp1heyz4q5grx6egk7bxmq) puedo bajar mi imagen reducida.

25)
    Por lo que vi, mi delta time (dt) anda por 0.025, a veces menos (0.01algo)

26)
    A veces los ogg no se escuchan, para ello debo modificar su tasa de muestreo (sampling rate) a 44100hz.
    Para subir el volumen a un ogg, con Audacity modificar la barrita a la izquierda que dice - + (no tocar la que dice L R).
    Para hacer estereo un ogg en audacity:
        Abriendo un audio por vez, elegir Edit/Duplicate.
        Luego ir al pequeño menusito que aparece al lado del nombre del archivo, que se muestra al apretar la
        flechita (bien a la izquierda) y elegir Make Stereo Track.

27)
    AbstractScreen implementa Screen y extiende Stage (Scene2d).
    Sea x una pantalla que extiende de AbstractScreen.
    Entonces, x.buildStage arma todo los actores de esa pantalla, es como el constructor.
    Luego si yo hago game.setScreen(x), libgdx invoca al render de Game que invoca al render de x.
    El render de x está definido en AbstractScreen e invoca al act y al draw de Stage.
    Yo hago game.setScreen dentro de ScreenManager y luego esta última hace x.dispose.
    ScreenManager maneja pantallas sobre las cuales navego, como el MainMenuScreen, PlayScreen, GameOverScreen, etc.
    El Hud la considero como una pantalla más, que extiende AbstractScreen (pues tiene camara como MainMenuScreen, GameOverScreen, etc.).
    Pero como no es administrada por ScreenManager, jamás se hace un game.setScreen(Hud), por ende, jamás se invoca al render de AbstractScreen.
    En este caso particular, como el Hud depende pura y exclusivamente de PlayScreen, es PlayScreen la que invoca a su buildStage, act, draw y
    dispose. Es decir, es PlayScreen la que haría lo que haría ScreenManager para el resto de las pantallas como MainMenuScreen, GameOverScreen, etc.

28)
    Para agregar publicidad:
    http://www.norakomi.com/tutorial_admob_part2_interstitial_ads.php
    https://www.youtube.com/watch?v=cwAN4LMXo58&feature=youtu.be

29) Para hacer un juego necesito:
    Programadores
    Diseñador gráfico: estetica de pantallas y personajes
    Animador para personajes
    Audio: Musica de fondo, efectos
    Campañas y recursos externos: para adMob, openFeint, redes sociales, playstore,
        avisos push al celular, sitios web propios, etc.
    Alquien que se encargue del diseño de niveles y sobre todas las cosas de la jubabilidad

30) Text to speech
    Para leer la historia inicial utilice:
    https://www.naturalreaders.com/online/ English Amanda
    Para la amenaza final utilice:
    http://www.oddcast.com/home/demos/tts/tts_example.php Daniel (UK). Effect Pitch lower.

    Para bajar los audios de ambos, con f12/Networks abri las urls que dicen Media. A veces si el texto
    es corto no aparecen, basta con hacer un texto más largo. Al abrir esas urls en otra tab, puedo bajar el audio.

    Para fusionar varios mp3s en uno solo, con audacity los abro todos. Supongamos que tengo track1 y track2, para
    fusionarlos (track1track2):
        - abro ambos
        - selecciono todo el track2 tocando el área donde dice el nombre del archivo (bien a la izquierda)
        - hago copy
        - hago paste al final de track1. Para seleccionar el punto final de track1 lo puedo hacer
          con el cursor del teclado (o sea, clickeo cualquier parte del track y luego muevo hacia la derecha
          con el teclado)

    Para poner background de fondo a un audio:
        - abro el primer audio, por ejemplo la voz que habla
        - hago drag and drop sobre ese audio con la musica background
        - ahi si doy play voy a ver que ambos se reproducen a la vez.
        - ajusto el volumen del background (con + -)
        - luego voy a file y le doy export, allí me avisa que va a fusionar todo en un track stereo.

31)
    Cada vez que libere un nuevo apk (Build/Generate Signed APK) para la playStore, debo
    incrementar versionCode de android/build.gradle.

32)
    Para saber donde esta el adb ir a Android studio/settings/Appearance & behavior/System Settings/Android SDK:
    C:\Alvaro\Develop\Android\20171202\AndroidSDK
    El adb esta en C:\Alvaro\Develop\Android\20171202\AndroidSDK\platform-tools
    Lo anterior tambien lo puedo ver en el archivo local.properties que esta dentro de mi proyecto (GameThree).

IOS
---
xcode para programar en objectiveC o en swift.
xcode funciona en mac, se usa un emulador para probar iphone o sino enchufar un iphone.
La licencia al parecer ahora es gratis.
Tengo links en bookmarks libgdx en donde habla de las opciones libgdx ios.
Bajar una maquina virtual, no comprar mac.
